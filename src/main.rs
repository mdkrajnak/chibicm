#![allow(clippy::uninlined_format_args)]

//! A program that generates ca certs, the associate private key, and signs CSRs
//! generated by certificate requestors.

mod ca;

use ca::{mk_private_key, mk_request};
use chrono::Utc;
use clap::{Arg, ArgMatches, Command};
use openssl::error::ErrorStack;
use openssl::x509::{X509Name, X509NameBuilder, X509VerifyResult};
use std::error::Error;
use std::io::Write;

/// A program that generates ca certs, certs verified by the ca, and public
/// and private keys.


fn now_as_str() -> String {
    let now = Utc::now();
    now.format("%Y%m%d%H%M%SZ").to_string()
}

fn real_main() -> Result<(), ErrorStack> {
    let (ca_cert, ca_key_pair) = ca::mk_simple_ca_cert(&now_as_str(), 365)?;

    let mut x509_name_builder = X509NameBuilder::new()?;
    x509_name_builder.append_entry_by_text("O", "GEHC")?;
    let x509_name = x509_name_builder.build();

    let (cert, _key_pair) = ca::mk_ca_signed_cert(&ca_cert, &ca_key_pair, &x509_name)?;

    // Verify that this cert was issued by this ca
    match ca_cert.issued(&cert) {
        X509VerifyResult::OK => println!("Certificate verified!"),
        ver_err => println!("Failed to verify certificate: {}", ver_err),
    };

    // Write the CA certificate to a file.
    let mut ca_certificate_file = std::fs::File::create("ca.pem").unwrap();
    ca_certificate_file.write_all(ca_cert.to_pem().unwrap().as_ref()).unwrap();

    // Write the CA private key to a file.
    let mut key_file = std::fs::File::create("ca-key.pem").unwrap();
    key_file.write_all(ca_key_pair.private_key_to_pem_pkcs8().unwrap().as_ref()).unwrap();

    // Write the client certificate to a file.
    let mut certificate_file = std::fs::File::create("client.pem").unwrap();
    certificate_file.write_all(cert.to_pem().unwrap().as_ref()).unwrap();

    Ok(())
}

fn add_arg_to_name(x509_builder: &mut X509NameBuilder, args: &ArgMatches, arg_name: &str, x509_name: &str) -> Result<(), ErrorStack> {
    let arg : Option<&String> = args.get_one(arg_name);
    if arg.is_some() {
        let value = arg.unwrap();
        if value.len() != 0 {
            x509_builder.append_entry_by_text(x509_name, arg.unwrap())?;
        }
    }
    Ok(())
}

fn name_from_args(args: &ArgMatches) -> Result<X509Name, ErrorStack> {
    let mut x509_builder = X509NameBuilder::new()?;

    add_arg_to_name(&mut x509_builder, &args, "name", "CN")?;
    add_arg_to_name(&mut x509_builder, &args, "country", "C")?;
    add_arg_to_name(&mut x509_builder, &args, "state", "ST")?;
    add_arg_to_name(&mut x509_builder, &args, "location", "L")?;
    add_arg_to_name(&mut x509_builder, &args, "organization", "O")?;
    add_arg_to_name(&mut x509_builder, &args, "unit", "OU")?;
    add_arg_to_name(&mut x509_builder, &args, "email", "emailAddress")?;
    
    Ok(x509_builder.build())
}

fn is_all_digits(string: &str) -> bool {
    string.chars().all(|c| c.is_digit(10))
}

fn run_new(args: &ArgMatches) -> Result<(), String> {
    
    // Tried doing this with unwrap_or(default) but it doesn't appear to work like I expect.
    let root = String::from("root");
    let name_option = args.get_one("name");
    let name = if name_option.is_some() { name_option.unwrap() } else { &root };
    
    let start_option : Option<&String> = args.get_one("start");
    let start = if start_option.is_some() {
        let temp = start_option.unwrap();
        if temp.len() != 8 {
            return Err(format!("Start time given: {}, must  be 8 characters long.", temp));
        };
        if !is_all_digits(&temp) {
            return Err(format!("The start time given: {},  contains characters that are not digits", temp));
        }
        let start_result = format!("{}000000Z", temp);
        start_result
    } else {
        let now = Utc::now();
        let default_start = now.format("%Y%m%d%H%M%SZ").to_string();
        default_start
    };

    let default_days: u32 = 365;
    let days: u32 = args.get_one("days").unwrap_or(&default_days).clone();
    
    let x509_name = name_from_args(&args).unwrap();
    let (ca_cert, ca_key_pair) = ca::mk_ca_cert(&x509_name, &start, days).unwrap();
        
    // Write the CA certificate to a file.
    let mut ca_certificate_file = std::fs::File::create(format!("{}.crt", name)).unwrap();
    ca_certificate_file.write_all(ca_cert.to_pem().unwrap().as_ref()).unwrap();
    
    // Write the CA private key to a file.
    let mut key_file = std::fs::File::create(format!("{}.key", name)).unwrap();
    key_file.write_all(ca_key_pair.private_key_to_pem_pkcs8().unwrap().as_ref()).unwrap();
    
    Ok(())
}

fn run_csr(args: &ArgMatches) -> Result<(), Box<dyn Error>> {
    // Tried doing this with unwrap_or(default) but it doesn't appear to work like I expect.
    let client = String::from("client");
    let name_option = args.get_one("name");
    let name = if name_option.is_some() { name_option.unwrap() } else { &client };
    
    let default_bits: u32 = 2048;
    let bits: u32 = args.get_one("bits").unwrap_or(&default_bits).clone();

    let x509_name = name_from_args(&args).unwrap();

    let key_pair = mk_private_key(bits)?;
    let csr = mk_request(&key_pair, &x509_name)?;

    // Write the client CSR to a file.
    let mut csr_file = std::fs::File::create(format!("{}.csr", name))?;
    csr_file.write_all(csr.to_pem().unwrap().as_ref())?;
    
    // Write the client private key to a file.
    let mut pub_key_file = std::fs::File::create(format!("{}.key", name))?;
    pub_key_file.write_all(key_pair.public_key_to_pem().unwrap().as_ref())?;

    // Write the client private key to a file.
    let mut key_file = std::fs::File::create(format!("{}-private.key", name))?;
    key_file.write_all(key_pair.private_key_to_pem_pkcs8().unwrap().as_ref())?;
    
    Ok(())
}

fn run_sign(args: &ArgMatches) -> Result<(), String> {
    Ok(())
}

fn run(args: &ArgMatches) -> Result<(), Box<dyn Error>> {
    match args.subcommand() {
        Some(("csr", subargs)) => run_csr(subargs)?,
        Some(("new", subargs)) => run_new(subargs)?,
        Some(("sign", subargs)) => run_sign(subargs)?,
        _ => println!("Unknown command"),
    };
    

//    match real_main() {
//        Ok(()) => println!("Finished."),
//        Err(e) => println!("Error: {}", e),
//    };
    Ok(())
}

fn main() -> Result<(), Box<dyn Error>> {
    let args = Command::new("chibica")
        .version("0.0.1")
        .about("Chibi CA")
        .subcommand(Command::new("exists")
            .about("Check to see if a CA exists.")
            .arg(Arg::new("ca")
                .long("ca")
                .help("Name of the new root CA")
                .default_value("root")))
        .subcommand(Command::new("new")
            .about("Create a new root CA")
            .arg(Arg::new("name")
                .long("name")
                .short('n')
                .help("The CA certificate common name (CN)")
                .default_value("root"))
            .arg(Arg::new("organization")
                .long("organization")
                .short('o')
                .help("The CA certificate organization (O)")
                .default_value(""))
            .arg(Arg::new("unit")
                .long("unit")
                .short('u')
                .help("The CA certificate organizational unit (OU)")
                .default_value(""))
            .arg(Arg::new("country")
                .long("country")
                .short('c')
                .help("The CA certificate country (C)")
                .default_value(""))
            .arg(Arg::new("state")
                .long("state")
                .short('s')
                .help("The CA certificate state (ST)")
                .default_value(""))
            .arg(Arg::new("location")
                .long("location")
                .short('l')
                .help("The location (L) to assign to the CA's certifcate")
                .default_value(""))
            .arg(Arg::new("email")
                .long("email")
                .short('e')
                .help("The email (emailAddress) to assign to the CA's certifcate")
                .default_value(""))
            .arg(Arg::new("bits")
                .long("bits")
                .short('b')
                .help("The number of bits to use when generating the private key")
                .default_value("2096"))
            .arg(Arg::new("start")
                .long("start")
                .help("The start date of the certificate in YYYYMMDD format"))
            .arg(Arg::new("days")
                .long("days")
                .short('d')
                .value_parser(clap::value_parser!(u32))
                .help("The number of days the certificate should be valid")
                .default_value("365")))
        .subcommand(Command::new("csr")
            .about("Create a CSR")
            .arg(Arg::new("name")
                .long("name")
                .short('n')
                .help("The certificate common name (CN)")
                .required(true))
            .arg(Arg::new("organization")
                .long("organization")
                .short('o')
                .help("The CA certificate organization (O)")
                .default_value(""))
            .arg(Arg::new("unit")
                .long("unit")
                .short('u')
                .help("The CA certificate organizational unit (OU)")
                .default_value(""))
            .arg(Arg::new("country")
                .long("country")
                .short('c')
                .help("The CA certificate country (C)")
                .default_value(""))
            .arg(Arg::new("state")
                .long("state")
                .short('s')
                .help("The CA certificate state (ST)")
                .default_value(""))
            .arg(Arg::new("location")
                .long("location")
                .short('l')
                .help("The location (L) to assign to the CA's certifcate")
                .default_value(""))
            .arg(Arg::new("email")
                .long("email")
                .short('e')
                .help("The email (emailAddress) to assign to the CA's certifcate")
                .default_value(""))
            .arg(Arg::new("bits")
                .long("bits")
                .short('b')
                .help("The number of bits to use when generating the private key")
                .default_value("2096")))
        .subcommand(Command::new("sign")
            .about("Sign a CSR")
            .arg(Arg::new("ca")
                .long("ca")
                .short('c')
                .help("The CA to use to sign the certificate, use 'list' to see the available CAs")
                .default_value("root"))
            .arg(Arg::new("in")
                .long("in")
                .short('i')
                .help("The CSR file with the request to sign")
                .required(true))
            .arg(Arg::new("out")
                .long("out")
                .short('o')
                .help("The name of the output file for the signed certificate")
                .required(true)))
        .get_matches();
    
    run(&args)?;
    
    Ok(())
}

